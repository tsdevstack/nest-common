import {
  INestApplication,
  ValidationPipe,
  Type,
  VersioningType,
} from "@nestjs/common";
import { NestFactory } from "@nestjs/core";
import helmet from "helmet";
import compression from "compression";
import express from "express";
import { SwaggerModule } from "@nestjs/swagger";
import dotenv from "dotenv";
import path from "path";
import fs from "fs";
import {
  createSwaggerDocument,
  SwaggerConfig,
} from "../open-api-docs/create-swagger-document";
import { loadFrameworkConfig } from "../config/load-framework-config";
import { readPackageJson, titleCase } from "../utils/package-json";

interface AppBootstrapOptions {
  port: number | string;
  globalPrefix: string;
  jsonLimit?: number;
  urlLimit?: number;
  enableShutdownHooks?: boolean;
  swagger: SwaggerConfig;
}

// Optional overrides for startApp
interface StartAppOptions {
  swagger?: SwaggerConfig;
  jsonLimit?: number;
  urlLimit?: number;
  enableShutdownHooks?: boolean;
}

export async function createApp<T>(
  AppModule: Type<T>,
  options: AppBootstrapOptions
): Promise<INestApplication> {
  const {
    globalPrefix,
    jsonLimit = 1,
    urlLimit = 1,
    enableShutdownHooks = true,
    swagger,
  } = options;

  // No validation here - CLI validates at dev/build time
  const app = await NestFactory.create(AppModule);

  // Set global prefix BEFORE versioning
  // Exclude infrastructure endpoints from prefix - they're accessed directly by Prometheus/K8s
  app.setGlobalPrefix(globalPrefix, {
    exclude: ['health', 'health/ping', 'metrics'],
  });

  // Enable URL versioning (comes after global prefix)
  app.enableVersioning({
    type: VersioningType.URI,
    prefix: "v",
  });

  // Security middleware
  app.use(
    helmet({
      crossOriginEmbedderPolicy: false, // Disable if there are iframe issues
      contentSecurityPolicy: {
        directives: {
          defaultSrc: ["'self'"],
          styleSrc: ["'self'", "'unsafe-inline'"],
          scriptSrc: ["'self'"],
          imgSrc: ["'self'", "data:", "https:"],
        },
      },
    })
  );

  // Compression
  app.use(compression());

  // Limit
  app.use(express.json({ limit: `${jsonLimit}mb` }));
  app.use(express.urlencoded({ limit: `${urlLimit}mb`, extended: true }));

  // CORS handled by Kong Gateway - no app-level CORS needed

  // Global validation pipe
  app.useGlobalPipes(
    new ValidationPipe({
      transform: true,
      whitelist: true, // Strip unknown properties
      forbidNonWhitelisted: true, // Reject requests with unknown properties
      disableErrorMessages: process.env.NODE_ENV === "production",
      transformOptions: {
        enableImplicitConversion: true,
      },
    })
  );

  if (enableShutdownHooks) {
    app.enableShutdownHooks();
  }

  // Setup Swagger in development
  if (process.env.NODE_ENV !== "production") {
    // Pass globalPrefix to swagger config for correct client generation
    const swaggerConfigWithPrefix = {
      ...swagger,
      globalPrefix,
    };
    const document = createSwaggerDocument(app, swaggerConfigWithPrefix);
    SwaggerModule.setup("api", app, document);
  }

  return app;
}

/**
 * Load .env file if it exists (local development only)
 *
 * In local development, .env file is generated by the CLI and contains SECRETS_PROVIDER.
 * In cloud/pipelines, platform sets environment variables directly (no .env file needed).
 *
 * Skips loading if SECRETS_PROVIDER is already set (cloud/pipeline environments).
 * Walks up directory tree to find .env (similar to how .secrets.local.json is found).
 * Silently ignores if .env doesn't exist - that's expected in cloud environments.
 * Does NOT overwrite existing environment variables (platform vars take precedence).
 */
export function loadEnvIfExists(): void {
  // Skip if SECRETS_PROVIDER is already set (cloud/pipeline environment)
  if (process.env.SECRETS_PROVIDER) {
    return;
  }

  let currentDir = process.cwd();
  const maxDepth = 10;
  let depth = 0;

  while (depth < maxDepth) {
    const envPath = path.join(currentDir, '.env');

    if (fs.existsSync(envPath)) {
      // Check if this .env file contains SECRETS_PROVIDER
      // (Service-level .env files may only contain DATABASE_URL for Prisma Studio)
      const envContent = fs.readFileSync(envPath, 'utf-8');
      const hasSecretsProvider = envContent.includes('SECRETS_PROVIDER=');

      if (hasSecretsProvider) {
        dotenv.config({ path: envPath });
        return;
      }
      // Otherwise, continue searching up the directory tree
    }

    const parentDir = path.dirname(currentDir);
    if (parentDir === currentDir) {
      break; // Reached filesystem root
    }

    currentDir = parentDir;
    depth++;
  }

  // .env not found - OK in cloud/pipeline environments
  // Platform will have set env vars directly
}

export async function startApp<T>(
  AppModule: Type<T>,
  options?: StartAppOptions
): Promise<void> {
  // 0. Load .env if it exists (local dev only)
  // Must happen BEFORE SecretsService instantiation since it needs SECRETS_PROVIDER
  loadEnvIfExists();

  // 1. Read service metadata from package.json
  const packageJson = readPackageJson();
  const serviceName = packageJson.name;

  // Set SERVICE_NAME for SecretsModule factory
  process.env.SERVICE_NAME = serviceName;

  // 2. Load framework configuration
  const frameworkConfig = loadFrameworkConfig(serviceName);
  console.log(`ðŸ“‹ Loaded framework config for ${serviceName}`);

  // 3. Auto-generate swagger config from package.json if not provided
  const swagger = options?.swagger || {
    title: titleCase(serviceName),
    description: packageJson.description || "",
    version: packageJson.version || "1.0.0",
  };

  // 5. Merge framework config with optional overrides
  // Use PORT env var (set by Cloud Run to 8080) or fall back to config port for local dev
  const port = process.env.PORT ? parseInt(process.env.PORT, 10) : frameworkConfig.port;
  const appConfig: AppBootstrapOptions = {
    port,
    globalPrefix: frameworkConfig.globalPrefix,
    swagger,
    jsonLimit: options?.jsonLimit,
    urlLimit: options?.urlLimit,
    enableShutdownHooks: options?.enableShutdownHooks,
  };

  // 6. Create and start the app
  const app = await createApp(AppModule, appConfig);
  // Bind to 0.0.0.0 for Cloud Run (default localhost blocks external connections)
  await app.listen(appConfig.port, '0.0.0.0');
}
